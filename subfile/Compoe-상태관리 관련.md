# 1. derivedStateOf
- **상태 변경 시에만 리컴포지션을 트리거하여 최적화**하는 방법
- 특정 상태에서 파생된 상태를 사용해야 할 때 사용되며, 이를 통해 **파생된 상태가 실제로 변경되었을 때에만 리컴포지션을 실행**하므로 리컴포지션을 최소화할 수 있음
- 사용 예시
  - 예를 들어, 목록의 크기를 기반으로 UI를 업데이트해야 하는 상황에서 derivedStateOf를 사용할 수 있음 -> 목록의 내용이 아닌 크기만을 감시하기 때문에 크기가 변경되지 않으면 리컴포지션 동작X
```kotlin
val itemCount by remember { derivedStateOf { list.size } }
```
- 작동 원리
  - 상태가 변경될 때에만 리컴포지션을 트리거하며, 필요 없는 리컴포지션을 방지해 앱 성능을 높임
  - 특히 계산량이 많은 파생 상태가 여러 번 사용될 때 효율적
 
# 2. LaunchedEffect
- **코루틴을 사용해 비동기 작업을 수행**하며, 컴포저블이 처음 구성될 때 한 번 실행되거나, 지정한 키 값이 변경될 때 다시 실행
- 주로 **비동기 작업**을 실행하거나 컴포저블 수명 주기에 맞춰 초기화 작업을 수행할 때 사용
- 사용 예시
  - API 호출이나 데이터베이스 읽기처럼 비동기 작업을 수행할 때 사용
  - 특정 화면이 로드될 때 네트워크 요청을 통해 데이터를 가져오고 싶다면 LaunchedEffect를 사용해 데이터를 불러올 수 있음
```kotlin
LaunchedEffect(key1 = true) {
    val data = fetchData()
    // 데이터 업데이트
}
```
- 작동 원리
  - 지정된 키 값이 변경되거나 컴포저블이 처음 등장할 때만 실행되며, 컴포저블이 구성된 동안 LaunchedEffect내 작업을 보장해 줌

# 3. SideEffect
- **리컴포지션 시 수행해야 하는 동작**을 처리하는 데 사용
- 일반적으로 Compose 외부 시스템과 상호작용할 때 사용
- 리컴포지션이 일어날 때마다 실행되어 **상태가 유지되면서 외부 시스템과 동기화**하는 데 유용
- 사용 예시
  - 로그 출력이나 Compose 외부의 데이터베이스, API 등 외부 시스템과 동기화할 때 유용
```kotlin
SideEffect {
    Log.d("Compose", "Composables recomposed!")
}
```
- 작동 원리
  - 모든 리컴포지션마다 실행되며, 컴포저블 외부 시스템과 상호작용할 수 있는 간단한 방법을 제공

# 4. DisposableEffect
- 컴포저블의 수명 주기를 기반으로 실행 및 정리 작업을 수행하는 구조
- **컴포저블이 사라질 때 정리가 필요한 작업을 할 때 사용**
- 예를 들어, 리스너를 등록하고 제거하거나 특정 리소스를 해제하는 데 유용
- 사용 예시
  - 센서 리스너, BroadcastReceiver, 혹은 네트워크 콜백 등 수명 주기에 맞춰 정리가 필요한 경우 사용
```kotlin
DisposableEffect(Unit) {
    val listener = createListener()
    listener.start()
    
    onDispose {
        listener.stop()
    }
}

```
- 작동 원리
  - 키 값이 변경되거나 컴포저블이 제거될 때 onDispose 블록을 호출하여 리소스를 정리
  - 포저블이 화면에서 사라질 때 자동으로 정리 작업을 실행

# 5. 요약
- **derivedStateOf**는 파생 상태가 변경될 때만 리컴포지션을 트리거하여 성능 최적화를 지원합니다.
- **LaunchedEffect**는 비동기 작업을 실행하며, 초기화나 데이터 가져오기 작업에 적합합니다.
- **SideEffect**는 리컴포지션 시 외부 시스템과의 상호작용을 위한 작업을 수행합니다.
- **DisposableEffect**는 컴포저블이 사라질 때 정리가 필요한 리소스나 작업을 관리합니다.
